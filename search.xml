<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搭建shadowsocks服务器]]></title>
    <url>%2F2017%2F11%2F26%2F%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[搭建shadowsocks服务器 之前用过一段时间的付费VPN,从收费价格上来讲与租主机相差不了多少,于是决定自己搭建shadowsocks服务器. 准备 AWS首尔节点开一台EC2配置相关的安全设置 用ssh 客户端连接到主机 检查python环境等 python --version 开始 检查并升级系统软件包 sudo apt install --upgrade; 安装==pip== sudo apt install python-pip (已经安装过的可以忽略); 下载shadowsocks ,pip install git+https://github.com/shadowsocks/shadowsocks.git@master 或者 pip install shadowscoks,如果没有什么意外,==shadowsocks==就已经安装好了; 安装shadowsocks所需要的加密模块: apt install python-m2crypto; 新建并编辑shadowsocks启动时的配置文件ssconfig.json 12345678910&#123; "server":"server_ip", "server_port":8388, "local_address":"127.0.0.1", "local_port":1080, "password":"mypassword", "timeout":600, "method":"aes-256-cfb", "fast_open":false&#125; 配置说明 参数名 解释 server 服务器Ip地址,//在配置过程中发现配置了服务器的真实地址后,启动shadowsocks报错,未找到原因,可以配置为0.0.0.0 server_port 服务器监听端口 local_adress 本地IP地址(可选) local_port 本地端口号 password 登录时所用的密码 timeout 超时时间 method 加密算法 默认 aes-256-cfb fast_open 是否使用TCP_FASTOPEN,true/false workers number of workers, available on Unix/Linux 启动shadowsocks:1sudo nohup ./ssserver -c /opt/software/ssconfig.json &gt; /opt/software/log &amp; 或者 1ssserver -c /opt/software/ssconfig.json -d start &gt; /opt/software/log == 注意: == 服务器防火墙设置入站规则要开启8388端口 到此vpn就已经搭建完毕,可以开启畅游之旅了]]></content>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jackson序列化null值处理]]></title>
    <url>%2F2017%2F11%2F19%2FJackson%E5%BA%8F%E5%88%97%E5%8C%96null%E5%80%BC%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Jackson在序列化数据为json格式的数据时，如果值为空时，默认的会转化为null值，但是在解析json数据时会出现JsonNull的异常错误。因此在序列化的时候需要考虑null问题。 我们可以自定义空值序列化器来避免这种情况。下面是项目中遇到的问题和解决方案，尚未深入研究Jackson源码，具体解决方案如下。(String类型的null值序列化为&quot;&quot;,JavaBean类型的null序列化为 {},Collection类型的null序列化为 [] ) 首先先了解一下几个重要的类： JsonSerializer&lt;T&gt;,SerializerProvider,ObjectMapper JsonSerializer&lt;T&gt; :抽象类，被 ObjectMapper用于把任意类型的对象序列化为JSON,一般使用 JsonGenerator.StdSerializer而不是这个类，因为它实现了这个类的很多方法。 注意： 如果值为空的话，serialize方法则不会被调用 ，调用者必须处理空值 ，通常通过调用 SerializerProvider.findNullValueSerializer(com.fasterxml.jackson.databind.BeanProperty) 获取可用的序列化器。也就是说在序列化空值时，自定义的序列化器不能直接用来改变输出。 SerializerProvider: 被 ObjectMapper 和 JsonSerializer 用来获取能够序列化指定类型实例的序列化器，另外提供了功能的默认实现。Provider 能够缓存序列化器处理的切面。所有构造细节都委托给 SerializerFactory实例。 对象生命周期就是：初始化实例（“blueprint”）被创建并且被ObjectMapper和ObjectWriter实例引用。但实际上的用法是：一个配置过的实例被子类 DefaultSerializerProvider通过一个创建方法给创建。只有这个实例可以用于实际的序列化调用，而blueprint仅仅用于创建实例。 ObjectMapper:该mapper（或着叫 data binder, codec）提供了在java 对象与JSON 结构之间的转换的功能。 它使用 象jsonParser和 JsonGenerator这些已经实现了JSON的读写功能的实例。主要的转换API已经在ObjectCodec类里实现，所以该类的实现细节不需要暴露给流式转化器和生成器类了。 了解了这几个类的作用，就可以设置自定义空值处理器了。 自定义String类型的序列化器： 1234567891011public class NullStringSerializer extends JsonSerializer&lt;Object&gt;&#123;public static final NullStringSerializer INSTANCE = new NullStringSerializer();@Overridepublic void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException, JsonProcessingException &#123; gen.writeString(""); &#125;&#125; 自定义POJO类型的序列化器： 1234567891011public class NullObjectSerializer extends JsonSerializer&lt;Object&gt; &#123;public static final NullObjectSerializer INSTANCE = new NullObjectSerializer();@Overridepublic void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException, JsonProcessingException &#123; gen.writeStartObject(); //write "&#123;" gen.writeEndObject(); //write "&#125;" &#125;&#125; 自定义Collection类型的序列化器： 1234567891011public class NullConllectionSerializer extends JsonSerializer&lt;Object&gt;&#123;public static final NullConllectionSerializer INSTANCE = new NullConllectionSerializer();@Overridepublic void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException, JsonProcessingException &#123; gen.writeStartArray(); // write "[" gen.writeEndArray(); // write "]" &#125;&#125; 自定义序列化器提供者： 1234567891011121314151617181920212223242526272829 public class CustomNullObjectProvider extends DefaultSerializerProvider &#123; private static final long serialVersionUID = 1L; public CustomNullObjectProvider() &#123; super(); &#125; public CustomNullObjectProvider(SerializerProvider src, SerializationConfig config, SerializerFactory jsf) &#123; super(src, config, jsf); &#125; @Override public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) &#123; return new CustomNullObjectProvider(this, config, jsf); &#125; @Override public JsonSerializer&lt;Object&gt; findNullValueSerializer(BeanProperty property) throws JsonMappingException &#123; if (property.getType().getRawClass().equals(String.class)) &#123;//判断String类型 return NullStringSerializer.INSTANCE; &#125; if (property.getType().isArrayType() || property.getType().isCollectionLikeType()) &#123;//判断Collection类型 return NullConllectionSerializer.INSTANCE; &#125; return NullObjectSerializer.INSTANCE; //java Object &#125;&#125; 创建ObjectMapper对象: 12345ObjectMapper objectMapper = new ObjectMapper()objectMapper.setSerializerProvider(new CustomNullObjectProvider());MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();converter.setDefaultCharset(Charset.forName("UTF-8"));converter.setObjectMapper(new CustomObjectMapper());]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>JSON</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
